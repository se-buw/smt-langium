grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

Model:
    elements+=Element*;

Element:
    Command; // FIXME:  

// symbol 〉 ::= 〈simple_symbol 〉| a sequence of whitespace and printable characters that starts and ends with | and does not otherwise include | or \
Symbol: ID;

// 〈simple_symbol 〉 ::= a non-empty sequence of letters, digits and the characters + - / * = % ? ! . $ _ ~ & ^ < > @ that does not start with a digit
terminal SIMPLE_SYMBOL:
    (LETTER | '+' ) 
    (LETTER | DIGIT | '+' )*;

// 〈keyword 〉 ::= :〈simple_symbol 〉
Keyword:
    ':' SIMPLE_SYMBOL;

// 〈spec_constant〉 ::= 〈numeral 〉 | 〈decimal 〉 | 〈hexadecimal 〉 | 〈binary 〉 | 〈string 〉
SpecConstant:
    NUMERAL | DECIMAL | HEXADECIMAL | BINARY | STRING;

// 〈s_expr 〉 ::= 〈spec_constant〉 | 〈symbol 〉 | 〈reserved 〉 | 〈keyword 〉| ( 〈s_expr 〉∗ )
SExpr:
    const=SpecConstant | symb=Symbol | keyWord = Keyword | PAR_OPEN exprs+=SExpr+ PAR_CLOSE;

// 〈index 〉 ::= 〈numeral 〉 | 〈symbol 〉
Index:
    num=NUMERAL | symbol=Symbol;

// 〈identifier 〉 ::= 〈symbol 〉 | ( _ 〈symbol 〉 〈index 〉+ )
Identifier:
    symbol=ID | (PAR_OPEN '_' symbol=ID indices+=Index+ PAR_CLOSE);

// 〈sort〉 ::= 〈identifier 〉 | ( 〈identifier 〉 〈sort〉+ )
Sort:
    identifier=Identifier | PAR_OPEN identifier=Identifier sorts+=Sort+ PAR_CLOSE;

//〈attribute_value〉 ::= 〈spec_dant〉 | 〈symbol 〉 | ( 〈s_expr 〉∗ )
AttributeValue:
    const=SpecConstant | symbol=Symbol | {AttributeValue} PAR_OPEN exprs+=SExpr* PAR_CLOSE;

//〈attribute〉 ::= 〈keyword 〉 | 〈keyword 〉 〈attribute_value〉
Attribute:
    keyWord=Keyword value=AttributeValue?;

// 〈qual_identifier 〉 ::= 〈identifier 〉 | ( as 〈identifier 〉 〈sort〉 )
QualIdentifier:
    id=Identifier | (PAR_OPEN 'as' id=Identifier sort=Sort PAR_CLOSE);

//〈var_binding 〉 ::= ( 〈symbol 〉 〈term〉 )
VarBinding:
    PAR_OPEN symbol=Symbol term=Term PAR_CLOSE;

// 〈sorted_var 〉 ::= ( 〈symbol 〉 〈sort〉 )
SortedVar:
    PAR_OPEN symbol=ID sort=Sort PAR_CLOSE;

// 〈pattern〉 ::= 〈symbol 〉 | ( 〈symbol 〉 〈symbol 〉+ )
Pattern:
    symbol=Symbol | (PAR_OPEN symbol=Symbol symbols+=Symbol+ PAR_CLOSE);


//<match_case〉 ::= ( 〈pattern〉 〈term〉 )
MatchCase:
    PAR_OPEN pattern=Pattern term=Term PAR_CLOSE;

//〈term〉 ::= 〈spec_constant〉
    // | 〈qual_identifier 〉
    // | ( 〈qual_identifier 〉 〈term〉+ )
    // | ( let ( 〈var_binding 〉+ ) 〈term〉 )
    // | ( forall ( 〈sorted_var 〉+ ) 〈term〉 )
    // | ( exists ( 〈sorted_var 〉+ ) 〈term〉 )
    // | ( match 〈term〉 ( 〈match_case〉+ ) )
    // | ( ! 〈term〉 〈attribute〉+ )
Term:
    TermConstant
    | TermIdentifier    
    | LetExpr
    | ForAll
    | Exists
    | Match 
    | TermAttribute
	;
	

@Override 
terminal ID: 
	(LETTER | '+' ) (LETTER | DIGIT | '+' )* 
	| '|' (PRINTABLE_CHAR)+ '|';

TermIdentifier:
	identifier= QualIdentifier 
	| CmdConstDeclRef  
	| CmdFunDeclRef
	| SortedVarRef
    | PAR_OPEN identifier=QualIdentifier terms+=Term+ PAR_CLOSE;
    
CmdConstDeclRef: decl=[CmdConstDecl];
CmdFunDeclRef: decl=[CmdFunDecl];
SortedVarRef: decl=[SortedVar];

TermConstant:
	const=SpecConstant;
LetExpr:
	PAR_OPEN 'let' PAR_OPEN var+=VarBinding+ PAR_CLOSE term=Term PAR_CLOSE;	
ForAll:
	PAR_OPEN 'forall' PAR_OPEN var+=SortedVar+ PAR_CLOSE term=Term PAR_CLOSE;
Exists:
	PAR_OPEN 'exists' PAR_OPEN var+=SortedVar+ PAR_CLOSE term=Term PAR_CLOSE;
Match:
	PAR_OPEN 'match' term=Term PAR_OPEN cases+=MatchCase+ PAR_CLOSE PAR_CLOSE;
TermAttribute:
	PAR_OPEN '!' term=Term PAR_OPEN attributes+=Attribute+ PAR_CLOSE PAR_CLOSE;
	
// Theories
//〈sort_symbol_decl 〉 ::= ( 〈identifier 〉 〈numeral 〉 〈attribute〉* )
SortSymbolDecl:
    PAR_OPEN name=Identifier NUMERAL attributes+=Attribute* PAR_CLOSE;

// 〈meta_spec_constant〉 ::= NUMERAL | DECIMAL | STRING
MetaSpecConstant:
    NUMERAL | DECIMAL | STRING;

// 〈fun_symbol_decl 〉 ::= ( 〈spec_constant〉 〈sort〉 〈attribute〉∗ )
//    | ( 〈meta_spec_constant〉 〈sort〉 〈attribute〉∗ )
//    | ( 〈identifier 〉 〈sort〉+ 〈attribute〉∗ )
FunSymbolDecl:
    PAR_OPEN SpecConstant Sort Attribute* PAR_CLOSE
    | PAR_OPEN MetaSpecConstant Attribute* PAR_CLOSE // FIXME: Sort
    | PAR_OPEN Identifier Sort+ Attribute* PAR_CLOSE
    ;

// 〈par_fun_symbol_decl 〉 ::= 〈fun_symbol_decl 〉
//      | ( par ( 〈symbol 〉+ ) ( 〈identifier 〉 〈sort〉+ 〈attribute〉∗ ) )
ParFunSymbolDecl:
	FunSymbolDecl
	| PAR_OPEN 'par' PAR_OPEN Symbol+ PAR_CLOSE PAR_OPEN Identifier Sort+ Attribute* PAR_CLOSE PAR_CLOSE
    ;
// 〈theory_attribute〉 ::= :sorts ( 〈sort_symbol_decl 〉+ )
    // | :funs ( 〈par_fun_symbol_decl 〉+ )
    // | :sorts-description 〈string 〉
    // | :funs-description 〈string 〉
    // | :definition 〈string 〉
    // | :values 〈string 〉
    // | :notes 〈string 〉
    // | 〈attribute〉

TheoryAttribute:
    ':' 'sorts' PAR_OPEN SortSymbolDecl+ PAR_CLOSE
    | ':' 'funs' PAR_OPEN ParFunSymbolDecl+ PAR_CLOSE
    | ':' 'sorts-description' STRING
    | ':' 'funs-description' STRING
    | ':' 'definition' STRING
    | ':' 'values' STRING
    | ':' 'notes' STRING
    | Attribute
    ;

// 〈theory_decl 〉 ::= ( theory 〈symbol 〉 〈theory_attribute〉+ )
TheoryDecl:
    PAR_OPEN 'theory' Symbol TheoryAttribute+ PAR_CLOSE;



// Logic
// 〈logic_attribute〉 := :theories ( 〈symbol 〉+ )
    // | :language 〈string 〉
    // | :extensions 〈string 〉
    // | :values 〈string 〉
    // | :notes 〈string 〉
    // | 〈attribute〉
LogicAttribute:
    ':' 'theories' PAR_OPEN Symbol+ PAR_CLOSE
    | ':' 'language' STRING
    | ':' 'extensions' STRING
    | ':' 'values' STRING
    | ':' 'notes' STRING
    | Attribute
    ;

// 〈logic〉 ::= ( logic 〈symbol 〉 〈logic_attribute〉+ )
Logic:
    PAR_OPEN 'logic' Symbol LogicAttribute+ PAR_CLOSE;

// Info Flags
// info_flag 〉 ::= :all-statistics | :assertion-stack-levels | :authors
//     | :error-behavior | :name | :reason-unknown
//     | :version | 〈keyword 〉
InfoFlag:
    ':' 'all-statistics' | ':' 'assertion-stack-levels' | ':' 'authors'
    | ':' 'error-behavior' | ':' 'name' | ':' 'reason-unknown'
    | ':' 'version' | Keyword
    ;

// Command Options
// <b_value〉 ::= true | false
BValue:
    'true' | 'false';

// 〈option〉 ::= :diagnostic-output-channel 〈string 〉
    // | :global-declarations 〈b_value〉
    // | :interactive-mode 〈b_value〉
    // | :print-success 〈b_value〉
    // | :produce-assertions 〈b_value〉
    // | :produce-assignments 〈b_value〉
    // | :produce-models 〈b_value〉
    // | :produce-proofs 〈b_value〉
    // | :produce-unsat-assumptions 〈b_value〉
    // | :produce-unsat-cores 〈b_value〉
    // | :random-seed 〈numeral 〉
    // | :regular-output-channel 〈string 〉
    // | :reproducible-resource-limit 〈numeral 〉
    // | :verbosity 〈numeral 〉
    // | 〈attribute〉
Option:
    ':' 'diagnostic-output-channel' STRING
    | ':' 'global-declarations' BValue
    | ':' 'interactive-mode' BValue
    | ':' 'print-success' BValue
    | ':' 'produce-assertions' BValue
    | ':' 'produce-assignments' BValue
    | ':' 'produce-models' BValue
    | ':' 'produce-proofs' BValue
    | ':' 'produce-unsat-assumptions' BValue
    | ':' 'produce-unsat-cores' BValue
    | ':' 'random-seed' NUMERAL
    | ':' 'regular-output-channel' STRING
    | ':' 'reproducible-resource-limit' NUMERAL
    | ':' 'verbosity' NUMERAL
    | Attribute
    ;


// Commands

// 〈sort_dec〉 ::= ( 〈symbol 〉 〈numeral 〉 )
SortDec:
    PAR_OPEN name=ID numeral=NUMERAL PAR_CLOSE;

//〈selector_dec〉 ::= ( 〈symbol 〉 〈sort〉 )
SelectorDec:
    PAR_OPEN Symbol Sort PAR_CLOSE;

// 〈constructor_dec〉 ::= ( 〈symbol 〉 〈selector_dec〉∗ )
ConstructorDec:
    PAR_OPEN Symbol SelectorDec* PAR_CLOSE;

// 〈datatype_dec〉 ::= ( 〈constructor_dec〉+ ) | ( par ( 〈symbol 〉+ ) ( 〈constructor_dec〉+ ) )
DataTypeDec:
    PAR_OPEN ConstructorDec+ PAR_CLOSE
    | PAR_OPEN 'par' PAR_OPEN Symbol+ PAR_CLOSE PAR_OPEN ConstructorDec+ PAR_CLOSE PAR_CLOSE
    ;

// 〈function_dec〉 ::= ( 〈symbol 〉 ( 〈sorted_var 〉∗ ) 〈sort〉 )
FunctionDec:
    PAR_OPEN Symbol PAR_OPEN SortedVar* PAR_CLOSE Sort PAR_CLOSE;

// 〈function_def 〉 ::= 〈symbol 〉 ( 〈sorted_var 〉∗ ) 〈sort〉 〈term〉
FunctionDef:
    Symbol PAR_OPEN SortedVar* PAR_CLOSE Sort Term;

// 〈prop_literal 〉 ::= 〈symbol 〉 | ( not 〈symbol 〉 )
PropLiteral:
    Symbol | PAR_OPEN 'not' Symbol PAR_CLOSE;

// 〈command 〉 ::= ( assert 〈term〉 )
//     | ( check-sat )
//     | ( check-sat-assuming ( 〈prop_literal 〉∗ ) )
//     | ( declare-const 〈symbol 〉 〈sort〉 )
//     | ( declare-datatype 〈symbol 〉 〈datatype_dec〉)
//     | ( declare-datatypes ( 〈sort_dec〉n+1 ) ( 〈datatype_dec〉n+1 ) )
//     | ( declare-fun 〈symbol 〉 ( 〈sort〉∗ ) 〈sort〉 )
//     | ( declare-sort 〈symbol 〉 〈numeral 〉 )
//     | ( define-fun 〈function_def 〉 )
//     | ( define-fun-rec 〈function_def 〉 )
//     | ( define-funs-rec ( 〈function_dec〉n+1 ) ( 〈term〉n+1 ) )
//     | ( define-sort 〈symbol 〉 ( 〈symbol 〉∗ ) 〈sort〉 )
//     | ( echo 〈string 〉 )
//     | ( exit )
//     | ( get-assertions )
//     | ( get-assignment )
//     | ( get-info 〈info_flag 〉 )
//     | ( get-model )
//     | ( get-option 〈keyword 〉 )
//     | ( get-proof )
//     | ( get-unsat-assumptions )
//     | ( get-unsat-core )
//     | ( get-value ( 〈term〉+ ) )
//     | ( pop 〈numeral 〉 )
//     | ( push 〈numeral 〉 )
//     | ( reset )
//     | ( reset-assertions )
//     | ( set-info 〈attribute〉 )
//     | ( set-logic 〈symbol 〉 )
//     | ( set-option 〈option〉 )
Command:
    CmdAssert
    | CmdBasic
    | PAR_OPEN 'check-sat-assuming' PAR_OPEN PropLiteral* PAR_CLOSE PAR_CLOSE
    | CmdConstDecl
    | PAR_OPEN 'declare-datatype' name=ID DataTypeDec PAR_CLOSE
    | PAR_OPEN 'declare-datatypes' PAR_OPEN SortDec+ PAR_CLOSE PAR_OPEN DataTypeDec+ PAR_CLOSE
    | CmdFunDecl
    | PAR_OPEN 'declare-sort' name=ID NUMERAL PAR_CLOSE
    | PAR_OPEN 'define-fun' FunctionDef PAR_CLOSE
    | PAR_OPEN 'define-fun-rec' FunctionDef PAR_CLOSE
    | PAR_OPEN 'define-funs-rec' PAR_OPEN FunctionDec+ PAR_CLOSE PAR_OPEN Term+ PAR_CLOSE
    | PAR_OPEN 'define-sort' Symbol PAR_OPEN Symbol* PAR_CLOSE Sort PAR_CLOSE
    | PAR_OPEN 'echo' STRING PAR_CLOSE
    | PAR_OPEN 'exit' PAR_CLOSE
    | PAR_OPEN 'get-assertions' PAR_CLOSE
    | PAR_OPEN 'get-assignment' PAR_CLOSE
    | PAR_OPEN 'get-info' InfoFlag PAR_CLOSE
    | PAR_OPEN 'get-option' Keyword PAR_CLOSE
    | PAR_OPEN 'get-proof' PAR_CLOSE
    | PAR_OPEN 'get-unsat-assumptions' PAR_CLOSE
    | PAR_OPEN 'get-unsat-core' PAR_CLOSE
    | PAR_OPEN 'get-value' PAR_OPEN Term+ PAR_CLOSE PAR_CLOSE
    | PAR_OPEN 'pop' NUMERAL PAR_CLOSE
    | PAR_OPEN 'push' NUMERAL PAR_CLOSE
    | PAR_OPEN 'set-info' Attribute PAR_CLOSE
    | PAR_OPEN 'set-logic' Symbol PAR_CLOSE
    | PAR_OPEN 'set-option' Option PAR_CLOSE
    ;

CmdBasic:
	PAR_OPEN cmd=BasicCommand PAR_CLOSE
;
CmdConstDecl:
	PAR_OPEN 'declare-const' name=ID sorts+=Sort PAR_CLOSE
;
CmdFunDecl:
	PAR_OPEN 'declare-fun' name=ID PAR_OPEN paramSorts+=Sort* PAR_CLOSE returnSort=Sort PAR_CLOSE
;
enum BasicCommand: 
	CHECK_SAT = 'check-sat' 
	| RESET = 'reset'
	| RESET_ASSERTIONS = 'reset-assertions'
	| GET_MODEL = 'get-model'	
;

CmdAssert:
	PAR_OPEN 'assert' term=Term PAR_CLOSE
;


//〈script〉 ::= 〈command 〉∗
Script:
    {Script} commands+=Command*;

// Command Response

// 〈error-behavior 〉 ::= immediate-exit | continued-execution
ErrorBehavior:
    'immediate-exit' | 'continued-execution';

// 〈reason-unknown〉 ::= memout | incomplete | 〈s_expr 〉
ReasonUnknown:
	sExpr=SExpr
    | simpleReason=('memout' | 'incomplete');

// 〈model_response〉 ::= ( define-fun 〈function_def 〉 ) 
//      | ( define-fun-rec 〈function_def 〉 )
//      | ( define-funs-rec ( 〈function_dec〉n+1 ) ( 〈term〉n+1 ) )
ModelResponse:
    PAR_OPEN 'define-fun' FunctionDef PAR_CLOSE
    | PAR_OPEN 'define-fun-rec' FunctionDef PAR_CLOSE
    | PAR_OPEN 'define-funs-rec' PAR_OPEN FunctionDec+ PAR_CLOSE PAR_OPEN Term+ PAR_CLOSE // FIXME: n+1
    ;

// 〈info_response〉 ::= :assertion-stack-levels 〈numeral 〉
    // | :authors 〈string 〉
    // | :error-behavior 〈error-behavior 〉
    // | :name 〈string 〉
    // | :reason-unknown 〈reason-unknown〉
    // | :version 〈string 〉
    // | 〈attribute〉
InfoResponse:
    ':' 'assertion-stack-levels' NUMERAL
    | ':' 'authors' STRING
    | ':' 'error-behavior' ErrorBehavior
    | ':' 'name' STRING
    | ':' 'reason-unknown' ReasonUnknown
    | ':' 'version' STRING
    | Attribute
    ;

// 〈valuation_pair 〉 ::= ( 〈term〉 〈term〉 )
ValuationPair:
    PAR_OPEN Term Term PAR_CLOSE;

// 〈t_valuation_pair 〉 ::= ( 〈symbol 〉 〈b_value〉 )
TValuationPair:
    PAR_OPEN Symbol BValue PAR_CLOSE;

//〈check_sat_response〉 ::= sat | unsat | unknown
CheckSatResponse:
    'sat' | 'unsat' | 'unknown';

// 〈echo_response〉 ::= 〈string 〉
EchoResponse:
    STRING;

// 〈get_assertions_response〉 ::= ( 〈term〉∗ )
GetAssertionsResponse:
    PAR_OPEN Term* PAR_CLOSE;

// 〈get_assignment_response〉 ::= ( 〈t_valuation_pair 〉∗ )
GetAssignmentResponse:
    PAR_OPEN TValuationPair* PAR_CLOSE;
    
// 〈get_info_response〉 ::= ( 〈info_response〉+ )
GetInfoResponse:
    PAR_OPEN InfoResponse+ PAR_CLOSE;

// 〈get_model_response〉 ::= ( 〈model_response〉∗ )
GetModelResponse:
    PAR_OPEN ModelResponse* PAR_CLOSE;

// 〈get_option_response〉 ::= 〈attribute_value〉
GetOptionResponse:
    AttributeValue;

// 〈get_proof_response〉 ::= 〈s_expr 〉
GetProofResponse:
    SExpr;

// 〈get_unsat_assump_response〉 ::= ( 〈symbol 〉∗ )
GetUnsatAssumpResponse:
    PAR_OPEN Symbol* PAR_CLOSE;

// 〈get_unsat_core_response〉 ::= ( 〈symbol 〉∗ )
GetUnsatCoreResponse:
    PAR_OPEN Symbol* PAR_CLOSE;

// 〈get_value_response〉 ::= ( 〈valuation_pair 〉+ )
GetValueResponse:
    PAR_OPEN ValuationPair+ PAR_CLOSE;

// 〈specific_success_response〉 ::= 〈check_sat_response〉 | 〈echo_response〉
    // | 〈get_assertions_response〉 | 〈get_assignment_response〉
    // | 〈get_info_response〉 | 〈get_model_response〉
    // | 〈get_option_response〉 | 〈get_proof_response〉
    // | 〈get_unsat_assumptions_response〉
    // | 〈get_unsat_core_response〉 | 〈get_value_response〉
SpecificSuccessResponse:
    CheckSatResponse | EchoResponse
    | GetAssertionsResponse | GetAssignmentResponse
    | GetInfoResponse | GetModelResponse
// FIXME: 
//    | GetOptionResponse | GetProofResponse
//    | GetUnsatAssumpResponse
//    | GetUnsatCoreResponse | GetValueResponse
    ;

// 〈general_response〉 ::= success | 〈specific_success_response〉
    // | unsupported | ( error 〈string 〉 )
GeneralResponse:
    'success' | SpecificSuccessResponse | 'unsupported' | PAR_OPEN 'error' STRING PAR_CLOSE;






// ----------------------------------------------
// Tokens
terminal PAR_OPEN: '(';
terminal PAR_CLOSE: ')';
// 〈digit〉 ::= 0 | · · · | 9
terminal DIGIT: '0'..'9';
//<letter 〉 ::= A | · · · | Z | a | · · · | z
terminal LETTER: 'A'..'Z' | 'a'..'z';
//〈numeral 〉 ::= 0 | a non-empty sequence of digits not starting with 0
terminal NUMERAL: '0' | ('1'..'9') ('0'..'9')*;
// 〈decimal 〉 ::= 〈numeral 〉.0∗〈numeral 〉
terminal DECIMAL: NUMERAL '.' NUMERAL;
// 〈hexadecimal 〉 ::= #x followed by a non-empty sequence of digits and letters from A to F , capitalized or not
terminal HEXADECIMAL: '#x' ('0'..'9' | 'A'..'F' | 'a'..'f')+;
// 〈binary 〉 ::= #b followed by a non-empty sequence of 0 and 1 characters
terminal BINARY: '#b' ('0' | '1')+;
//~string 〉 ::= sequence of whitespace and printable characters in double quotes with escape sequence ""
@Override
terminal STRING: '"' (WHITE_SPACE | PRINTABLE_CHAR)* '"';

// ----------------------------------------------
// Auxiliary Lexical Categories
// 〈white_space_char 〉 ::= 9dec | 10dec | 13dec | 32dec
terminal WHITE_SPACE: ' ' | '\t' | '\r' | '\n';

// 〈printable_char 〉 ::= 32dec | · · · | 126dec | 128dec | · · · | 255dec
terminal PRINTABLE_CHAR:  ('\u0020'..'\u007E' | '\u0080'..'\u00FF');

